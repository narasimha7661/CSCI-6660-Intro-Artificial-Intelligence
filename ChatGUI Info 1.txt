
'''This code implements a simple chatbot using Python and the Tkinter library for creating a graphical user interface (GUI)
    The code begins by importing the necessary libraries:
    nltk: For natural language processing tasks.
    WordNetLemmatizer: A lemmatizer from NLTK for word lemmatization.
    pickle: For serializing and deserializing Python objects.
    numpy: For numerical operations.
    keras: A high-level neural networks API.
    json: For working with JSON data.
    random: For generating random responses..'''
#Importing Libraries:
import nltk
from nltk.stem import WordNetLemmatizer
lemmatizer = WordNetLemmatizer()
import pickle
import numpy as np

'''Loading the Pre-trained Model and Data:
    The code loads a pre-trained model (chatbot_model.h5) using Keras. This model is presumably trained on intents and responses
    The intents and associated responses are loaded from a JSON file (intents.json).
    Additionally, pickled files (words.pkl and classes.pkl) containing pre-processed word data and classes are loaded.'''
from keras.models import load_model
model = load_model('chatbot_model.h5')
import json
import random
intents = json.loads(open('intents.json').read())
words = pickle.load(open('words.pkl','rb'))
classes = pickle.load(open('classes.pkl','rb'))

#Functions for Processing Text:

'''The clean_up_sentence function tokenizes and lemmatizes the user's input sentence. This process involves breaking the sentence into words and reducing them to their base or root form.'''

def clean_up_sentence(sentence):
    # tokenize the pattern - split words into array
    sentence_words = nltk.word_tokenize(sentence)
    # stem each word - create short form for word
    sentence_words = [lemmatizer.lemmatize(word.lower()) for word in sentence_words]
    return sentence_words

# return bag of words array: 0 or 1 for each word in the bag that exists in the sentence

'''The bow function converts the tokenized and lemmatized sentence into a bag of words representation. Each word is assigned a binary value (1 or 0) based on its presence in the sentence'''

def bow(sentence, words, show_details=True):
    # tokenize the pattern
    sentence_words = clean_up_sentence(sentence)
    # bag of words - matrix of N words, vocabulary matrix
    bag = [0]*len(words)  
    for s in sentence_words:
        for i,w in enumerate(words):
            if w == s: 
                # assign 1 if current word is in the vocabulary position
                bag[i] = 1
                if show_details:
                    print ("found in bag: %s" % w)
    return(np.array(bag))

'''The predict_class function predicts the intent of the user's input using the trained model. It returns a list of intents sorted by probability.'''
def predict_class(sentence, model):
    # filter out predictions below a threshold
    p = bow(sentence, words,show_details=False)
    res = model.predict(np.array([p]))[0]
    ERROR_THRESHOLD = 0.25
    results = [[i,r] for i,r in enumerate(res) if r>ERROR_THRESHOLD]
    # sort by strength of probability
    results.sort(key=lambda x: x[1], reverse=True)
    return_list = []
    for r in results:
        return_list.append({"intent": classes[r[0]], "probability": str(r[1])})
    return return_list

'''The getResponse function selects a random response associated with the predicted intent from the loaded intents file.'''
def getResponse(ints, intents_json):
    tag = ints[0]['intent']
    list_of_intents = intents_json['intents']
    for i in list_of_intents:
        if(i['tag']== tag):
            result = random.choice(i['responses'])
            break
    return result

'''chatbot_response(msg): Gets the chatbot's response given the user's message.'''
def chatbot_response(msg):
    ints = predict_class(msg, model)
    res = getResponse(ints, intents)
    return res


#Creating GUI with tkinter
'''Tkinter is used to create a simple graphical user interface for the chatbot.
   The interface includes a text box for displaying the conversation, an entry box for user input, and a button to send messages
   The send function is triggered when the user clicks the send button. It retrieves the user's input, sends it to the chatbot for              processing, and updates the conversation log with user and bot messages'''

import tkinter
from tkinter import *


def send():
    msg = EntryBox.get("1.0",'end-1c').strip()
    EntryBox.delete("0.0",END)

    if msg != '':
        ChatLog.config(state=NORMAL)
        ChatLog.insert(END, "You: " + msg + '\n\n')
        ChatLog.config(foreground="#442265", font=("Verdana", 12 ))
    
        res = chatbot_response(msg)
        ChatLog.insert(END, "Bot: " + res + '\n\n')
            
        ChatLog.config(state=DISABLED)
        ChatLog.yview(END)
 

base = Tk()
base.title("Hello")
base.geometry("400x500")
base.resizable(width=FALSE, height=FALSE)

#Create Chat window
'''ChatLog: Text widget for displaying the conversation'''
ChatLog = Text(base, bd=0, bg="white", height="8", width="50", font="Arial",)

ChatLog.config(state=DISABLED)

#Bind scrollbar to Chat window
'''scrollbar: Scrollbar for the chat window.'''

scrollbar = Scrollbar(base, command=ChatLog.yview, cursor="heart")
ChatLog['yscrollcommand'] = scrollbar.set

#Create Button to send message
'''SendButton: Button for sending messages.'''

SendButton = Button(base, font=("Verdana",12,'bold'), text="Send", width="12", height=5,
                    bd=0, bg="#32de97", activebackground="#3c9d9b",fg='#ffffff',
                    command= send )

#Create the box to enter message
'''EntryBox: Text widget for entering messages.'''

EntryBox = Text(base, bd=0, bg="white",width="29", height="5", font="Arial")
#EntryBox.bind("<Return>", send)


#Place all components on the screen
scrollbar.place(x=376,y=6, height=386)
ChatLog.place(x=6,y=6, height=386, width=370)
EntryBox.place(x=128, y=401, height=90, width=265)
SendButton.place(x=6, y=401, height=90)

base.mainloop()
